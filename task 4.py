# -*- coding: utf-8 -*-
"""
Взгляните на показанный ниже
код, в котором используется цикл while и флаг found
для поиска в списке тепеней 2 занания 2, вовзевдённую в пятую степень

@author: workk
"""


def old():
    L = [1, 2, 4, 8, 16, 32, 64]
    X = 5
    found = False
    i = 0
    while not found and i < len(L):
        if 2**X == L[i]:
            found = True
        else:
            i = i + 1

    if found:
        print("at index", i)
    else:
        print(X, "not found")


"""
Код явно написан с использованием альтернативной логики.

Попробуйте оптимизировать код c использование рекомендаций,
они являются не обязатальными, но помогут понять основные ошибки.

а)  сначала перепишите код с конструкцией else цикла while, 
    чтобы избавиться от флага found и финального оператора if.
б)  затем перепишите код для использования цикла for с конструкцией else,
    чтобы избавиться от явной логики индексации списка. 
    (Подсказка: для получения индекса элемента применяйте списковый метод 
    index — L. index (X) возвращает смещение первого элемента X в списке L.)
в)  далее полностью устраните цикл, переписав код с использованием простого
    выражения с операцией членства in. (За дополнительными сведениями
    обращайтесь в главу 8 или наберите для тестирования 2 in [1,2,3].)
г)  наконец, примените цикл for и списковый метод append для генерации списка
    степеней 2 (L) вместо жесткого кодирования спискового литерала.


Ниже приведены более глубокие рассуждения.
д)  Как вы думаете, улучшит ли производительность перенос выражения 2 ** X
    за пределы циклов? Каким образом вы представили бы это в коде?
е)  Python содержит инструмент тар (функция, список), который также способен
    генерировать список степеней 2:. Каким образом можно его задать ? 
"""


def main():
    nums = [1, 2, 4, 8, 16, 32, 64]
    x = 5

    power_of_2 = 2**x

    for i, n in enumerate(nums):
        if n == power_of_2:
            print(i)
            return

    print("not found")


if __name__ == "__main__":
    main()
